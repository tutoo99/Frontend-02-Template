学习笔记
第一节：从3分30秒开始。
浏览器的基本原理：从URL-> BitMap ->显卡驱动->光信号
实现一个Toy-Browser
URL 获取 html文本，进行文本解析parse ，构成一个Dom树（只有html的信息），然后根据CSS 规则（CSS叠加，覆盖）产生一颗带CSS 属性的Dom树,然后根据元素盒子的位置进行layout布局，再经过浏览器渲染render形成一个BitMap位图，最终经过显卡驱动，将位图转为人类可识别的光信号。


第二节：有限状态机处理字符串
有限状态机并不对应无限状态机（实际上没有无限）
有限状态机 重点在机上 不在“状态”上，最大的特点，每一个机器都是一个状态，
之所以用有限状态机去处理编程问题，是因为有限状态机中每个机器都是解藕的，正因为每个机器都是独立的
这个特性，让有限状态机变为一个非常强有力的抽象机制。
1.在每一个机器里，都可以做计算，存储，输出。。。，也就意味着可以完全忽略其他状态机里的逻辑，只关心本状态要处理什么逻辑；比如说我们的状态机有个广泛的应用。游戏里敌人的ai,当游戏主角不跑到敌人攻击的范围内，敌人是不会攻击的，这里就可以用状态机去区分 攻击状态和等待状态，处于等待状态的敌人只需要处理主角是否进入攻击范围一个逻辑即可，而处于攻击状态的敌人可能需要处理多个逻辑，比如主角是否走远，主角是否呆在原地等。
2.所有的机器接受的输入都是一致的。比如，要么是字符串 ，要么是整数，要么是字符串和整数
3.状态机的每个机器本身不能再有状态，如果用函数来表示，它应该是纯函数，无副作用的（不受外部输入的控制，修改变量，返回值这些不受影响），可以往外写，但是不能再从外部读变量进来。一旦读了，再影响到状态机本身的状态切换逻辑，就会出大问题。
4.每个机器都必须要知道自己的下一个状态是什么
Moore状态机，每个机器都有确定的下一个状态，也就是说从状态a不管接受什么输入一定能进入到状态b,而不是说会因为输入做分支。

Mealy状态机，根据输入决定下一个状态，大多数时候比较实用的状态机，这种强大带来了代码的复杂性，也带来了强的表达能力


js中的有限状态机（Mealy)
Function.  state(input){
 
      Return  next;//返回值作为下一个状态，返回值是一个状态函数
}

while(input){

 State = state(input);
}
3.状态机，不使用状态机处理字符串
在一个字符串中，找到字符“a”
在一个字符串中，找到字符串ab
